mads 2.1.0 build 8 (23 Dec 19)
Source: C:\CC65\Projects\VBXE\VBXE wrapper\main.asm
     1 				; main.asm
     2
     3 				    org $2000
     4
     5 				.proc main
     6
     7 				    ; turn off ANTIC DMA
     8 FFFF> 2000-2DFF> A9 00 +     mva #$00 DMACTL
     9
    10 				    ; disable OS
    11 2005 20 D4 2D		    jsr disable_os
    12
    13 				    ; init VBXE
    14 2008 20 21 20		    jsr vbxe.initialize
    15 				    
    16 200B			main_loop
    17 200B 20 C7 2D		    jsr wait_for_default_vblank
    18
    19 				    ; screen address is $BC40 (for default display list)
    20 200E A2 04		    ldx #4
    21 2010			loop_text
    22 2010 BD 1D 20		    lda text,x 
    23 2013 9D FF BC		    sta $BCFF,x 
    24 2016 CA			    dex 
    25 2017 10 F7		    bpl loop_text
    26
    27
    28 2019 4C 0B 20		    jmp main_loop
    29
    30 201C 60			    rts 
    31 				.endp ; main
    32
    33 201D			text 
    34 201D 76 62 78 65		    dta 'v','b','x','e'
    35
    36 2021			    icl 'sys_defs.h'
Source: C:\CC65\Projects\VBXE\VBXE wrapper\sys_defs.h
     1 				;##################################################
     2 				; sys_defs.h 
     3 				;##################################################
     4
     5
     6 				;##################################################
     7 				; Zero Page
     8 				;##################################################
     9 = 00B0			ZP_SRC  equ $B0
    10 = 00B2			ZP_DST  equ $B2
    11 = 00B3			ZP_TMP  equ $B3
    12 				;##################################################
    13 				; dli & vbi vectors
    14 				;##################################################
    15 = 0200			VDSLST                  equ $200
    16 = 0222			VVBLKI                  equ $222
    17 				;##################################################
    18 				; display list
    19 				;##################################################
    20 = 0040			LMS                 equ 64
    21 = 0010			DLIST_HSCROLL       equ 16
    22 = 0020			DLIST_VSCROLL       equ 32
    23 = 0004			ANTIC_MODE_4        equ 4
    24
    25 = 0000			BLANK1              equ $00
    26 = 0010			BLANK2              equ $10
    27 = 0060			BLANK7              equ $60
    28 = 0070			BLANK8              equ $70
    29 = 0080			DLI                 equ 128
    30 = 0001			DLISTJUMP           equ $01
    31 = 0041			DLISTENDJUMP        equ $41
    32
    33 				;##################################################
    34 				; hardware registers
    35 				;##################################################
    36 = D01E			HITCLR          equ $D01E 
    37 = D300			PORTA           equ $D300
    38 = D301			PORTB           equ $D301
    39 = D20E			IRQEN           equ $D20E
    40 = FFFA			NMI          	equ $FFFA
    41 = D401			CHACTL          equ $D401
    42 = D40E			NMIEN           equ $D40E
    43 = D40F			NMIRES          equ $D40F
    44 = D400			DMACTL          equ $D400
    45 = D402			DLISTL          equ $D402
    46 = D409			CHBASE          equ $D409
    47 = D40A			WSYNC           equ $D40A
    48 = D40B			VCOUNT          equ $D40B
    49 = D404			HSCROL          equ $D404
    50 = D20A			RANDOM          equ $D20A
    51 = D012			COLPM0          equ $D012
    52 = D013			COLPM1          equ $D013
    53 = D014			COLPM2          equ $D014
    54 = D015			COLPM3          equ $D015
    55 = D016			COLPF0          equ $D016
    56 = D017			COLPF1          equ $D017
    57 = D018			COLPF2          equ $D018
    58 = D019			COLPF3          equ $D019
    59 = D01A			COLBK           equ $D01A
    60 = D000			HPOSP0          equ $D000
    61 = D001			HPOSP1          equ $D001
    62 = D002			HPOSP2          equ $D002
    63 = D003			HPOSP3          equ $D003
    64 = D004			HPOSM0          equ $D004
    65 = D005			HPOSM1          equ $D005
    66 = D006			HPOSM2          equ $D006
    67 = D007			HPOSM3          equ $D007
    68 = D008			SIZEP0          equ $D008
    69 = D009			SIZEP1          equ $D009
    70 = D00A			SIZEP2          equ $D00A
    71 = D00B			SIZEP3          equ $D00B
    72 = D00C			SIZEM           equ $D00C
    73 = D010			TRIG0           equ $D010
    74 = D01D			GRACTL          equ $D01D
    75 = D407			PMBASE          equ $D407
    76 = D01B			PRIOR           equ $D01B
    77 = D01F			CONSOL          equ $D01F
    78 = D500			BANK_BASE       equ $D500
    79
    80
    37 2021			    icl 'vbxe.asm'
Source: C:\CC65\Projects\VBXE\VBXE wrapper\vbxe.asm
     1 				;*********************************************************
     2 				; VBXE.asm
     3 				;*********************************************************
     4
     5 				; VBXE namespace
     6 2021			.proc vbxe  
     7
     8 				;*********************************************************
     9 				; proc name:  initialize
    10 				; purpose:    initializes VBXE, call this method first
    11 				;*********************************************************
    12 2021			.proc initialize
    13 2021 20 47 20		    jsr check_vbxe  
    14
    15 				    enable_xdl #0 ; disabled
    15 				 LDX# 0\ JSR VBXE.ENABLE_XDL
    15 2024 A2 00		 LDX# 0
    15 2026 20 03 21		 JSR VBXE.ENABLE_XDL
    16
    17 2029 20 71 20		    jsr setup_vbxe_memac
    18 202C 20 78 20		    jsr setup_vbxe_xdl
    19 202F 20 64 21		    jsr setup_vbxe_clear_screen_bcb
    20 2032 20 09 21		    jsr start_blitter    
    21 2035 20 A3 20		    jsr setup_vbxe_palette
    22 2038 20 CA 20		    jsr setup_vbxe_sprite_data
    23
    24 203B 20 7C 21		    jsr vbxe.setup_vbxe_sprite_draw_bcb 
    25 203E 20 09 21		    jsr vbxe.start_blitter 
    26 				    
    27 				    enable_xdl #VBXE_VIDEO_CONTROL_XDL_ENABLED ; disable
    27 				 LDX# VBXE_VIDEO_CONTROL_XDL_ENABLED\ JSR VBXE.ENABLE_XDL
    27 2041 A2 01		 LDX# VBXE_VIDEO_CONTROL_XDL_ENABLED
    27 2043 20 03 21		 JSR VBXE.ENABLE_XDL
    28
    29 				    
    30 2046 60			    rts 
    31 				.endp ;initialize
    32
    33 				;*********************************************************
    34 				; proc name:  check_vbxe
    35 				; purpose:    as VBXE board has few versions, we need to 
    36 				;             check if locations $D600 or $D700 are used
    37 				;             if not --> vbxe is not installed 
    38 				;*********************************************************
    39 2047			.proc check_vbxe 
    40 				    ; set $D600 into base address ZP variable 
    41 2047 A9 00 85 A0 A9 D6 +     mwa #VBXE_D600 VBXE_BASE_ADDR
    42 204F 20 60 20		    jsr detect_vbxe 
    43 2052 F0 0B		    beq exit_check
    44 				    ; if $D600 was not recognized, check $D700
    45 2054 E6 A1		    inc VBXE_BASE_ADDR+1
    46 2056 20 60 20		    jsr detect_vbxe 
    47 2059 F0 04		    beq exit_check 
    48 				    ; no VBXE installed --> set to 0 
    49 205B A9 00 85 A0		    mva #$00 VBXE_BASE_ADDR 
    50
    51 205F			exit_check
    52 205F 60			    rts 
    53 				.endp ;check_vbxe
    54
    55 				;*********************************************************
    56 				; proc name:  detect_vbxe
    57 				; purpose:    check major (core) and minor versions at
    58 				;             locations base+40 and base+41 respectively 
    59 				;*********************************************************
    60 2060			.proc detect_vbxe
    61 				    ; check FX 1.xx (location $40)
    62 2060 A0 40		    ldy #VBXE_CORE_VERSION
    63 2062 B1 A0		    lda (VBXE_BASE_ADDR),y
    64 2064 C9 10		    cmp #$10    
    65 2066 D0 08		    bne exit_detect 
    66 				    ; check minor version (location $41)
    67 2068 A0 41		    ldy #VBXE_MINOR_VERSION
    68 206A B1 A0		    lda (VBXE_BASE_ADDR),y
    69 				    ; the following and was recommended to do in
    70 				    ; the VBXE documentation to avoid minor version differences 
    71 206C 29 70		    and #$70
    72 206E C9 20		    cmp #$20    
    73
    74 2070			exit_detect 
    75 2070 60			    rts
    76 				.endp; detect_vbxe
    77
    78 				;*********************************************************
    79 				; proc name:  setup_vbxe_memac
    80 				; purpose:    set up MEMAC-A memory for VBXE
    81 				;             that means set the address space for it
    82 				;             choose the access (CPU/VBXE) 
    83 				;             and choose the memory size
    84 				;*********************************************************
    85 2071			.proc setup_vbxe_memac   
    86 				    
    87 					;-------------------------------------------------------    
    88 				    ; set MEMAC-A memory 
    89 				    ; set the MEMAC-A window address
    90 				    ; set CPU access
    91 				    ; set 4K size  
    92 					;-------------------------------------------------------
    93 2071 A0 5E		    ldy #VBXE_MEMAC_CTRL
    94 2073 A9 98		    lda #(>VBXE_MEMC_WINDOW + MEMC_CPU_ENABLE + MEMC_SIZE_4K) 	
    95 2075 91 A0			sta	(VBXE_BASE_ADDR),y 	
    96
    97 2077 60			    rts 
    98 				.endp ; setup_vbxe_memac
    99
   100 				;*********************************************************
   101 				; proc name:  setup_vbxe_xdl
   102 				; purpose:    the XDL defines the screen type 
   103 				;             resolution, scanlines and other 
   104 				;             copy xdl data to MEMAC-A memory window
   105 				;             and setup xdl addressed in the vbxe memory 
   106 				;             address space 
   107 				;*********************************************************
   108 2078			.proc setup_vbxe_xdl 
   109
   110 				    ; since we're using a standard resolution screen 
   111 				    ; with 320x192 pixels, and each pixel takes 1 byte
   112 				    ; the standard resolution screen will take 
   113 				    ; the address space $000000-$00EFFF (size of $F000) 
   114 				    ; in the VBXE memory address space
   115 				    ; so anything else beside the screen memory 
   116 				    ; should be above this address (above $00F000)
   117 				    ; to set this address we need to select the proper bank
   118 				    ; each bank is aligned to $1000 
   119 				    ; set XDL to the $00F000 address
   120 				    ; select bank $0F where the XDL will reside
   121 				    ; and enalbe the MEMAC-A window  
   122 				    
   123 				    ; store current bank for later use
   124 2078 A9 0F 85 A2		    mva #$0F VBXE_CURRENT_BANK
   125
   126 207C A0 5F		    ldy #VBXE_MEM_BANK_SEL
   127 207E A5 A2		    lda VBXE_CURRENT_BANK
   128 2080 18			    clc 
   129 2081 69 80		    adc #MEMAC_GLOBAL_ENABLE
   130 2083 91 A0		    sta (VBXE_BASE_ADDR),y 
   131
   132 				    ; copy the xdl data into the MEMAC-A window address space
   133 				    ; then set the XDL address to point to the VBXE addres
   134 				    ; space that will be used for the XDL
   135
   136 2085 A2 0C		    ldx #(XDL_DATA_LEN-1)
   137 2087			loop
   138 2087 BD 94 21		    lda	XDL_DATA,x 
   139 208A 9D 00 90		    sta	VBXE_MEMC_WINDOW,X 
   140 208D CA			    dex 
   141 208E 10 F7		    bpl loop 
   142
   143 				    ; as explained above, the XDL in VBXE address space will
   144 				    ; reside in $00F000 and on
   145 				    ; but the XDL data was copied to the MEMAC-A window address
   146 				    
   147 2090 A0 41		    ldy #VBXE_XDL_ADR0      ; low byte
   148 2092 A9 00		    lda	#$00
   149 2094 91 A0			sta	(VBXE_BASE_ADDR),y	
   150 2096 A0 42		    ldy #VBXE_XDL_ADR1      ; mid byte
   151 2098 A9 F0		    lda #$F0                  
   152 209A 91 A0			sta	(VBXE_BASE_ADDR),y	
   153 209C A0 43		    ldy #VBXE_XDL_ADR2      ; high byte
   154 209E A9 00		    lda #$00
   155 20A0 91 A0			sta	(VBXE_BASE_ADDR),y	
   156 				    
   157 20A2 60			    rts 
   158 				.endp ;setup_vbxe_xdl
   159
   160 				;*********************************************************
   161 				; proc name:  setup_vbxe_palette
   162 				; purpose:    copy the rgb palette bin file
   163 				;             data into VBXE memory 
   164 				;*********************************************************
   165 20A3			.proc setup_vbxe_palette
   166
   167 				    ; the sprite sheet data contains rgb color data as well
   168 				    ; this is reflected in the palette bin file
   169 				    ; copy the palette bin file data into VBXE rgb registers
   170 				    ; the rgb bin file contains 256 values for 
   171 				    ; r,g and b respectively, we copy all of them 
   172 				    ; start from palette 0 and color 0
   173 				    
   174 				    ; select palette 0
   175 20A3 A0 45		    ldy #VBXE_PSEL
   176 20A5 A9 00		    lda #0 
   177 20A7 91 A0		    sta (VBXE_BASE_ADDR),y 
   178
   179 				    ; select color 0 
   180 20A9 A0 44		    ldy #VBXE_CSEL
   181 20AB A9 00		    lda #0 
   182 20AD 91 A0		    sta (VBXE_BASE_ADDR),y 
   183
   184 				    ; loop all rgb values
   185 20AF A2 00		    ldx #0
   186
   187 20B1			loop_rgb
   188 				    ; red 
   189 20B1 A0 46		    ldy #VBXE_CR
   190 20B3 BD A7 2A		    lda	palette_bin,x 
   191 20B6 91 A0		    sta (VBXE_BASE_ADDR),y 
   192 				    ; green 
   193 20B8 A0 47		    ldy #VBXE_CG 
   194 20BA BD A7 2B		    lda palette_bin+$100,x 
   195 20BD 91 A0		    sta (VBXE_BASE_ADDR),y 
   196 				    ; blue
   197 20BF A0 48		    ldy #VBXE_CB 
   198 20C1 BD A7 2C		    lda palette_bin+$100+$100,x 
   199 20C4 91 A0		    sta (VBXE_BASE_ADDR),y 
   200 				    
   201 				    ; color selection (VBXE_CSEL) will increment automatically
   202 20C6 E8			    inx 
   203 20C7 D0 E8		    bne loop_rgb
   204 				    
   205 20C9 60			    rts 
   206 				.endp ;setup_vbxe_palette
   207
   208 				;*********************************************************
   209 				; proc name:  setup_vbxe_sprite_data
   210 				; purpose:    copy the sprite bin file data 
   211 				;             into MEMAC-A window memory 
   212 				;             take into account the MEMAC-A window size
   213 				;             you have defined and see if the sprite sheet
   214 				;             does not exceed that
   215 				;*********************************************************
   216 20CA			.proc setup_vbxe_sprite_data
   217 				    
   218 				    ; copy the sprite into the MEMAC-A VBXE address
   219 				    ; the offset needs to take into account the XDL
   220 				    ; and the blitter blocks so we set the address
   221 				    ; to be the MEMAC-A window address + $100 as offset
   222 				    ; $100 is enough as we only have 2 blitter blocks  
   223 				    ; that takes 2x21 = 42 bytes
   224 				    
   225 				    ; set the bin file hi byte address 
   226 				    ; into a ZP source variable
   227 20CA A9 CB 85 B0 A9 21 +     mwa #sprite_data ZP_SRC 
   228
   229 				    ; set the MEMAC-A window + offset($100) address  
   230 				    ; into a ZP destination variable 
   231 20D2 A9 00		    lda #0
   232 20D4 85 B2		    sta ZP_DST 
   233 20D6 A9 91		    lda #>(VBXE_MEMC_WINDOW + $100)
   234 20D8 85 B3		    sta ZP_DST + 1
   235
   236 				    ; loop sprite height 
   237 20DA A2 51		    ldx #SPRITE_HEIGHT
   238 20DC			copy_sprite_row_loop
   239 20DC A0 50		    ldy #SPRITE_HEIGHT-1
   240 20DE			copy_sprite_byte_loop
   241 20DE B1 B0		    lda (ZP_SRC),y
   242 20E0 91 B2		    sta (ZP_DST),y
   243 20E2 88			    dey
   244 20E3 10 F9		    bpl copy_sprite_byte_loop
   245 20E5 18			    clc
   246 20E6 A5 B0		    lda ZP_SRC
   247 20E8 69 1C		    adc #SPRITE_WIDTH
   248 20EA 85 B0		    sta ZP_SRC
   249 20EC A5 B1		    lda ZP_SRC + 1
   250 20EE 69 00		    adc #0
   251 20F0 85 B1		    sta ZP_SRC + 1
   252
   253 20F2 18			    clc
   254 20F3 A5 B2		    lda ZP_DST 
   255 20F5 69 1C		    adc #SPRITE_WIDTH
   256 20F7 85 B2		    sta ZP_DST 
   257 20F9 A5 B3		    lda ZP_DST + 1
   258 20FB 69 00		    adc #0
   259 20FD 85 B3		    sta ZP_DST + 1
   260
   261 20FF CA			    dex
   262 2100 D0 DA		    bne copy_sprite_row_loop
   263
   264 2102 60			    rts 
   265 				.endp ;setup_vbxe_sprite_data
   266
   267 				;*********************************************************
   268 				; proc name:  enable_xdl
   269 				; parameters: 0=disable, 1=enable
   270 				; purpose:    sets 0/1 in VBXE video control to enable
   271 				;             or disable the display
   272 				;*********************************************************
   273 2103			.proc enable_xdl(.byte x).reg 
   274 				    
   275 				    ; x-reg holds enable/disable
   276 				    ; enable/disable XDL
   277 2103 A0 40		    ldy #VBXE_VIDEO_CONTROL
   278 2105 8A			    txa 
   279 2106 91 A0		    sta (VBXE_BASE_ADDR),y 
   280
   281 2108 60			    rts 
   282 				.endp ; enable_xdl
   283
   284 				;*********************************************************
   285 				; proc name:  start_blitter
   286 				; purpose:    once blitter is free (not busy)
   287 				;             start 
   288 				;*********************************************************
   289 2109			.proc start_blitter 
   290 				    ; first wait for blitter busy to finish
   291 2109 20 13 21		    jsr wait_for_blitter
   292
   293 210C A0 53		    ldy #VBXE_BLITTER_START
   294 210E A9 01		    lda #$01 
   295 2110 91 A0		    sta (VBXE_BASE_ADDR),y 
   296 				    
   297 2112 60			    rts 
   298
   299 				.endp ; start_blitter
   300
   301 				;*********************************************************
   302 				; proc name:  wait_for_blitter
   303 				; purpose:    read the register BLITTER BUSY 
   304 				;             and wait till its not busy anymore
   305 				;*********************************************************
   306 2113			.proc wait_for_blitter
   307 				    ; read the blitter busy register
   308 				    ; if it is 0 -->it is ready  
   309 2113 A0 53		    ldy #VBXE_BLITTER_BUSY
   310 2115			do_wait
   311 2115 B1 A0		    lda (VBXE_BASE_ADDR),y
   312 2117 D0 FC		    bne do_wait 
   313 				    
   314 2119 60			    rts
   315 				.endp ; wait_for_blitter
   316
   317 				;*********************************************************
   318 				; proc name:  setup_vbxe_blitter_block
   319 				; purpose:    you need to set before calling this proc
   320 				;             ZP_SRC and 3 bytes for VBXE_MEM_ADDR    
   321 				;             from the VBXE 3 bytes address 
   322 				;             we take the bank , and set it 
   323 				;             and we set the ZP_DST 
   324 				;             and the 3 bytes blitter address 
   325 				;*********************************************************
   326 211A			.proc setup_vbxe_blitter_block
   327 				    ; source was set before the call to this proc
   328 				    ; set the destination 
   329 				    ; the VBXE address is with this format $00-F0-00
   330 				    ; we need to get the half part of the high byte
   331 				    ; and half part of the mid byte to select the proper
   332 				    ; VBXE bank  
   333 				    
   334 				    ; load mid byte 
   335 211A A5 A4		    lda VBXE_MEM_ADDR+1 
   336 				    ; store it temporary 
   337 211C 85 B3		    sta ZP_TMP
   338 				    ; load high byte 
   339 211E A5 A5		    lda VBXE_MEM_ADDR+2
   340 				    ; 4 shifts 4 rolls to get the half byte and half byte  
   341 2120 06 B3		    asl ZP_TMP 
   342 2122 2A			    rol 
   343 2123 06 B3		    asl ZP_TMP 
   344 2125 2A			    rol 
   345 2126 06 B3		    asl ZP_TMP 
   346 2128 2A			    rol 
   347 2129 06 B3		    asl ZP_TMP 
   348 212B 2A			    rol 
   349
   350 				    ; select the bank for this address of VBXE
   351 				    ; restore current bank back 
   352 212C A0 5F		    ldy #VBXE_MEM_BANK_SEL
   353 				    ; acc holds the bank  
   354 212E 18			    clc 
   355 212F 69 80		    adc #MEMAC_GLOBAL_ENABLE
   356 2131 91 A0		    sta (VBXE_BASE_ADDR),y 
   357
   358 				    ; we need to add to the MEMAC-A window the offset 
   359 				    ; of the VBXE address 
   360 2133 A5 A3		    lda VBXE_MEM_ADDR
   361 2135 85 B2		    sta ZP_DST 
   362 2137 A5 A4		    lda VBXE_MEM_ADDR+1
   363 				    ; extrac the 3rd digit 
   364 2139 29 0F		    and #$0F 
   365 213B 09 90		    ora #>VBXE_MEMC_WINDOW
   366 213D 85 B3		    sta ZP_DST+1 
   367
   368 				    ; loop copy
   369 213F A0 14		    ldy #BCB_SIZE-1
   370
   371 2141			copy_loop
   372 2141 B1 B0		    lda (ZP_SRC),y
   373 2143 91 B2		    sta (ZP_DST),y
   374 2145 88			    dey
   375 2146 10 F9		    bpl copy_loop
   376 				    
   377 				    ; set the blitter address in VBXE memory address space
   378 				    ; $00F00E
   379 2148 A0 50		    ldy #VBXE_BL_ADR0 ; low byte
   380 214A A5 A3		    lda VBXE_MEM_ADDR 
   381 214C 91 A0		    sta (VBXE_BASE_ADDR),y 
   382
   383 214E A0 51		    ldy #VBXE_BL_ADR1 ; mid byte
   384 2150 A5 A4		    lda VBXE_MEM_ADDR+1   
   385 2152 91 A0		    sta (VBXE_BASE_ADDR),y 
   386
   387 2154 A0 52		    ldy #VBXE_BL_ADR2 ; high byte
   388 2156 A5 A5		    lda VBXE_MEM_ADDR+2 
   389 2158 91 A0		    sta (VBXE_BASE_ADDR),y 
   390
   391
   392 				    ; restore current bank back 
   393 215A A0 5F		    ldy #VBXE_MEM_BANK_SEL
   394 215C A5 A2		    lda VBXE_CURRENT_BANK  
   395 215E 18			    clc 
   396 215F 69 80		    adc #MEMAC_GLOBAL_ENABLE
   397 2161 91 A0		    sta (VBXE_BASE_ADDR),y 
   398
   399 2163 60			    rts 
   400 				.endp ;setup_vbxe_blitter_block
   401
   402 				;*********************************************************
   403 				; proc name:  setup_vbxe_clear_screen_bcb
   404 				; purpose:    set up the ZP_SRC to bcb clear screen data
   405 				;             set up the vbxe address to $00F00E
   406 				;             the bank will be $0F as the MEMAC window is set 
   407 				;             to 4K size so all banks addresses are 
   408 				;             aligned with $1000 
   409 				;*********************************************************
   410 2164			.proc setup_vbxe_clear_screen_bcb
   411 				    ; copy the blitter address to ZP source varialbe 
   412 2164 A9 B6 85 B0 A9 21 +     mwa #BCB_CLEAR_SCREEN ZP_SRC
   413 				    
   414 				    ; set blitter block to $00F00E
   415 216C A9 0E 85 A3		    mva #$0E VBXE_MEM_ADDR
   416 2170 A9 F0 85 A4		    mva #$F0 VBXE_MEM_ADDR+1
   417 2174 A9 00 85 A5		    mva #$00 VBXE_MEM_ADDR+2
   418
   419 2178 20 1A 21		    jsr setup_vbxe_blitter_block
   420
   421 217B 60			    rts
   422 				.endp ;setup_vbxe_clear_screen_bcb 
   423
   424 				;*********************************************************
   425 				; proc name:  setup_vbxe_sprite_draw_bcb
   426 				; purpose:    set up the ZP_SRC to bcb sprite draw data
   427 				;             set up the vbxe address to $00F023
   428 				;             each blitter block is 21 bytes and last
   429 				;             block was set to $00F00E
   430 				;             the bank will be $0F again as the MEMAC window is set 
   431 				;             to 4K size so all banks addresses are 
   432 				;             aligned with $1000 
   433 				;*********************************************************
   434 217C			.proc setup_vbxe_sprite_draw_bcb
   435 				    
   436 				    ; copy the blitter address to ZP source varialbe 
   437 217C A9 A1 85 B0 A9 21 +     mwa #BCB_SPRITE_DRAW ZP_SRC
   438 				    
   439 				    ; set blitter block to $00F00E
   440 2184 A9 23 85 A3		    mva #$23 VBXE_MEM_ADDR
   441 2188 A9 F0 85 A4		    mva #$F0 VBXE_MEM_ADDR+1
   442 218C A9 00 85 A5		    mva #$00 VBXE_MEM_ADDR+2
   443
   444 2190 20 1A 21		    jsr setup_vbxe_blitter_block
   445
   446 2193 60			    rts
   447 				.endp ;setup_vbxe_sprite_draw_bcb 
   448
   449 				;---------------------------------------------
   450 				; include files
   451 2194			    icl 'vbxe.h'
Source: C:\CC65\Projects\VBXE\VBXE wrapper\vbxe.h
     1 				;-------------------------------------------
     2 				; vbxe.h
     3 				;-------------------------------------------
     4
     5 				;-------------------------------------------
     6 				; zero page base address for easy and fast access
     7 = 00A0			VBXE_BASE_ADDR    equ $A0 ; 2 bytes
     8 = 00A2			VBXE_CURRENT_BANK equ $A2 ; 1 byte
     9 = 00A3			VBXE_MEM_ADDR     equ $A3 ; 3 bytes
    10 				;-------------------------------------------
    11 				; D600/D700
    12 = D600			VBXE_D600 equ $D600 
    13 				;-------------------------------------------
    14
    15 				;-------------------------------------------
    16 				; MEMAC-A window address
    17 = 9000			VBXE_MEMC_WINDOW equ $9000
    18 				;-------------------------------------------
    19
    20 				;-------------------------------------------
    21 				; VBXE main registers 
    22 				; some of the registeres can be r/w  
    23 = 0040			VBXE_VIDEO_CONTROL equ $40  ; write
    24 = 0040			VBXE_CORE_VERSION  equ $40  ; read
    25
    26 = 0041			VBXE_XDL_ADR0      equ $41  ; write
    27 = 0041			VBXE_MINOR_VERSION equ $41  ; read
    28
    29 = 0042			VBXE_XDL_ADR1 equ $42 ; write
    30 = 0043			VBXE_XDL_ADR2 equ $43 ; write 
    31
    32 = 0044			VBXE_CSEL equ $44 ; write 
    33 = 0045			VBXE_PSEL equ $45 ; write 
    34
    35 = 0046			VBXE_CR equ $46 ; write
    36 = 0047			VBXE_CG equ $47 ; write
    37 = 0048			VBXE_CB equ $48 ; write 
    38
    39 = 0049			VBXE_COLMASK equ $49 ; write
    40
    41 = 004A			VBXE_COLCLR    equ $4A ; write
    42 = 004A			VBXE_COLDETECT equ $4A ; read
    43
    44 				; 4B-4F skipped, no use
    45
    46 = 0050			VBXE_BL_ADR0            equ $50 ; write 
    47 = 0050			VBXE_BLT_COLLISION_CODE equ $50 ; read
    48
    49 = 0051			VBXE_BL_ADR1            equ $51 ; write 
    50 = 0052			VBXE_BL_ADR2            equ $52 ; write 
    51
    52 = 0053			VBXE_BLITTER_START equ $53 ; write
    53 = 0053			VBXE_BLITTER_BUSY  equ $53 ; read 
    54
    55 = 0054			VBXE_IRQ_CONTROL equ $54 ; write 
    56 = 0054			VBXE_IRQ_STATUS  equ $54 ; read 
    57
    58 = 0055			VBXE_P0 equ $55 ; write
    59 = 0056			VBXE_P1 equ $56 ; write
    60 = 0057			VBXE_P2 equ $57 ; write
    61 = 0058			VBXE_P3 equ $58 ; write
    62
    63 				; 59-5C skipped, no use
    64
    65 = 005D			VBXE_MEMAC_B_CONTROL equ $5D ; write 
    66 = 005E			VBXE_MEMAC_CTRL      equ $5E ; write & read
    67
    68 = 005F			VBXE_MEM_BANK_SEL equ $5F ; write & read 
    69 				;-----------------------------------------
    70
    71 				;-----------------------------------------
    72 				; Video Control attributes
    73 = 0001			VBXE_VIDEO_CONTROL_XDL_ENABLED                  equ %00000001
    74 = 0002			VBXE_VIDEO_CONTROL_16_SHADES_ENABLED            equ %00000010
    75 = 0004			VBXE_VIDEO_CONTROL_DISABLE_OVERLAY_TRASPARENCY  equ %00000100
    76 = 0008			VBXE_VIDEO_CONTROL_ADD_ADDITINAL_TRANSPARENCY   equ %00001000
    77 				;-----------------------------------------
    78
    79 				;-----------------------------------------
    80 				; MEMAC attributes
    81 = 0000			MEMC_SIZE_4K        equ %00000000   ; 4k size
    82 = 0001			MEMC_SIZE_8K        equ %00000001   ; 8k size
    83 = 0002			MEMC_SIZE_16K       equ %00000010   ; 16k size
    84 = 0003			MEMC_SIZE_32K       equ %00000011   ; 32k size
    85 = 0004			MEMC_ANTIC_ENABLE   equ %00000100   ; ANTIC window access
    86 = 0008			MEMC_CPU_ENABLE     equ %00001000   ; CPU window access 
    87 				;-----------------------------------------
    88
    89 				;-----------------------------------------
    90 				; MEMS (MEMAC BANK SELECTION)
    91 = 0080			MEMAC_GLOBAL_ENABLE equ %10000000   ; enable the MEMAC window
    92 				;-----------------------------------------
    93
    94 				;-----------------------------------------
    95 				; XDLC controls definition
    96
    97 				; first byte 
    98 = 0001			XDLC_TMON   equ %00000001 ; Overlay text mode
    99 = 0002			XDLC_GMON   equ %00000010 ; Overlay graphics mode
   100 = 0004			XDLC_OVOFF  equ %00000100 ; disable overlay  
   101 = 0008			XDLC_MAPON  equ %00001000 ; enable color attributes
   102 = 0010			XDLC_MAPOFF equ %00010000 ; disavble color attributes
   103 = 0020			XDLC_RPTL   equ %00100000 ; repeat for the next x scanlines
   104 = 0040			XDLC_OVADR  equ %01000000 ; set the address of the Overlay display memory (screen memory) and the step of the overlay display (how many pixels per line) 
   105 = 0080			XDLC_OVSCRL equ %10000000 ; set scrolling values for the text mode
   106 				; second byte 
   107 = 0001			XDLC_CHBASE equ %00000001 ; sets the font (text mode)
   108 = 0002			XDLC_MAPADR equ %00000010 ; sets the address and step of the colour attribute map
   109 = 0004			XDLC_MAPPAR equ %00000100 ; sets the scrolling values, width and height of a field in the colour attribute map
   110 = 0008			XDLC_ATT    equ %00001000 ; sets the display size(Narrow=256 pixels, Normal=320 pixels, Wide = 336 pixels) the Overlay priority to the ANTIC display and the Overlay color modification
   111 = 0010			XDLC_HR     equ %00010000 ; enables the high resolution mode, works only with graphics mode, 640 pixels with 16 colors supported 
   112 = 0020			XDLC_LR     equ %00100000 ; enables the low resolution mode, works only with graphics mode, 160 pixels with 256 colors supported 
   113 				; bit 6 in second byte is not in use (reserved)
   114 = 0080			XDLC_END    equ %10000000 ; ends the XDL and wait for VSYNC to occur
   115
   116 				;-----------------------------------------
   117 				; XDLC XDLC_ATT first byte attributes
   118 				; OV_WIDTH
   119 = 0000			XDLC_ATT_OV_WIDTH_NARROW equ %00000000 ; bit 0,1=00(256 pixels)
   120 = 0001			XDLC_ATT_OV_WIDTH_NORMAL equ %00000001 ; bit 0,1=01(320 pixels)
   121 = 0002			XDLC_ATT_OV_WIDTH_WIDE   equ %00000010 ; bit 0,1=10(336 pixels)
   122 				; XDL OV PALETTE
   123 = 0000			XDLC_ATT_OV_PALETTE_00   equ %00000000 ; bit 4,5=00
   124 = 0010			XDLC_ATT_OV_PALETTE_01   equ %00010000 ; bit 4,5=01
   125 = 0020			XDLC_ATT_OV_PALETTE_10   equ %00100000 ; bit 4,5=10
   126 = 0030			XDLC_ATT_OV_PALETTE_11   equ %00110000 ; bit 4,5=11
   127 				; XDL PF PALETTE
   128 = 0000			XDLC_ATT_PF_PALETTE_00   equ %00000000 ; bit 6,7=00
   129 = 0040			XDLC_ATT_PF_PALETTE_01   equ %01000000 ; bit 6,7=01
   130 = 0080			XDLC_ATT_PF_PALETTE_10   equ %10000000 ; bit 6,7=10
   131 = 00C0			XDLC_ATT_PF_PALETTE_11   equ %11000000 ; bit 6,7=11
   132 				;-----------------------------------------
   133 				; XDLC XDLC_ATT second byte attributes
   134 				; MAIN_PRIORITY
   135 = 0001			XDLC_ATT_MAIN_PRIORITY_OVERLAY_PM0      equ %00000001 
   136 = 0002			XDLC_ATT_MAIN_PRIORITY_OVERLAY_PM1      equ %00000010 
   137 = 0004			XDLC_ATT_MAIN_PRIORITY_OVERLAY_PM2      equ %00000100 
   138 = 0008			XDLC_ATT_MAIN_PRIORITY_OVERLAY_PM3      equ %00001000 
   139 = 0010			XDLC_ATT_MAIN_PRIORITY_OVERLAY_PF0      equ %00010000 
   140 = 0020			XDLC_ATT_MAIN_PRIORITY_OVERLAY_PF1      equ %00100000 
   141 = 0040			XDLC_ATT_MAIN_PRIORITY_OVERLAY_PF2_PF3  equ %01000000 
   142 = 0080			XDLC_ATT_MAIN_PRIORITY_OVERLAY_COLBK    equ %10000000 
   143 = 00FF			XDLC_ATT_MAIN_PRIORITY_OVERLAY_ALL      equ %11111111
   144 				;-----------------------------------------
   145
   146 				;-----------------------------------------
   147 				; sprite sheet definitions
   148 = 001C			SPRITE_WIDTH    equ 28;16
   149 = 0051			SPRITE_HEIGHT   equ 81;21
   150 				;-----------------------------------------
   452 2194			    icl 'xdl_data.h'
Source: C:\CC65\Projects\VBXE\VBXE wrapper\xdl_data.h
     1 				; XDL data 
     2 				;-----------------------------------------
     3 				; XDL definition
     4 2194			XDL_DATA 
     5 				    ; top part of screen, overscan lines
     6 				    ; no overlay and repeat for 23 lines
     7 2194 24			    dta XDLC_OVOFF | XDLC_RPTL ; first byte 
     8 2195 00			    dta $0                     ; second byte, not used here
     9 2196 17			    dta $17                    ; repeat data $17=23
    10
    11 				; main part of the screen the
    12 				; graphics mode, repeat for 192 scanlines 
    13 				; setting overlay address $000000 and step
    14 2197 72			    dta XDLC_GMON | XDLC_MAPOFF | XDLC_RPTL | XDLC_OVADR ; first byte
    15 2198 88			    dta XDLC_ATT  | XDLC_END   ; second byte
    16 2199 C0			    dta $C0         ; repeat $C0=192 
    17 219A 00			    dta $00         ; overlay address $000000
    18 219B 00			    dta $00
    19 219C 00			    dta $00 
    20 219D 40			    dta $40        ; step $140=320 pixels per line
    21 219E 01			    dta $01
    22 219F 01			    dta XDLC_ATT_OV_WIDTH_NORMAL    ; NORMAL = 320 pixel
    23 21A0 FF			    dta XDLC_ATT_MAIN_PRIORITY_OVERLAY_ALL
    24
    25 = 000D			XDL_DATA_LEN equ *-XDL_DATA
   453 21A1			    icl 'bliiter_blocks.h'
Source: C:\CC65\Projects\VBXE\VBXE wrapper\bliiter_blocks.h
     1 				; blitter blocks
     2
     3 				;-----------------------------------------------
     4 				; blit data for "sprite"
     5 				;-----------------------------------------------
     6 21A1			BCB_SPRITE_DRAW
     7 				    ; BCB is 21 bytes long
     8 				    ; 3 bytes = address of the sprite data we are copying
     9 				    ; our sprite resides in VBXE memory $00F100
    10 21A1 00			    dta $00
    11 21A2 F1			    dta $F1
    12 21A3 00			    dta $00
    13 				    ; step Y - sprite width for each change of Y
    14 21A4 1C 00		    dta a(SPRITE_WIDTH)
    15 				    ; step X - step 1 byte each change of X
    16 21A6 01			    dta $1
    17 				    ; the address of middle of the VBXE visible screen
    18 21A7 80			    dta $80
    19 21A8 50			    dta $50
    20 21A9 00			    dta $00
    21 				    ; step Y - screen width in pixels $140 (320) 
    22 21AA 40 01		    dta a($140)
    23 21AC 01			    dta $1
    24 				    ; width of blitter to copy  
    25 21AD 1B 00		    dta a(SPRITE_WIDTH - 1)
    26 				    ; height of blitter to copy 
    27 21AF 50			    dta SPRITE_HEIGHT - 1
    28 				    ; AND mask for source
    29 21B0 FF			    dta $FF
    30 				    ; XOR mask for source
    31 21B1 00			    dta $00 
    32 				    ; AND mask collision detection
    33 21B2 00			    dta $00 
    34 				    ; ZOOM value X-Axis Y-Axis
    35 21B3 00			    dta $00
    36 				    ; Pattern fill 
    37 21B4 00			    dta $00
    38 21B5 01			    dta $01
    39
    40 				;-----------------------------------------------
    41 				; blit data for clear screen
    42 				;-----------------------------------------------
    43 21B6			BCB_CLEAR_SCREEN 
    44 				    ; BCB is 21 bytes long
    45 				    ; 3 bytes = address of the sprite data we are copying
    46 				    ; our sprite resides in VBXE memory $00F100
    47 21B6 00			    dta $00
    48 21B7 00			    dta $00
    49 21B8 00			    dta $00
    50 				    ; step Y - sprite width for each change of Y
    51 21B9 00 00		    dta a($0000) ; 320 - screen width
    52 				    ; step X - step 1 byte each change of X
    53 21BB 00			    dta $0
    54 				    ; the address of the VBXE screen top left
    55 21BC 00			    dta $00
    56 21BD 00			    dta $00
    57 21BE 00			    dta $00
    58 				    ; step Y - screen width in pixels $140 (320) 
    59 21BF 40 01		    dta a($140)
    60 				    ; step X - 1 pixel 
    61 21C1 01			    dta $01
    62 				    ; width of blitter to copy  
    63 21C2 3F 01		    dta a($140 - 1) 
    64 				    ; height of blitter to copy 
    65 21C4 BF			    dta $C0-$1 
    66 				    ; AND mask for source
    67 21C5 00			    dta $00
    68 				    ; XOR mask for source
    69 21C6 00			    dta $00
    70 				    ; AND mask collision detection
    71 21C7 00			    dta $00 
    72 				    ; ZOOM value X-Axis Y-Axis
    73 21C8 00			    dta $00
    74 				    ; Pattern fill 
    75 21C9 00			    dta $00
    76 21CA 00			    dta $00
    77
    78 = 0015			BCB_SIZE equ 21
    79
   454 21CB			sprite_data
   455 21CB 00 00 00 00 00 00 +     ins 'sprite_monster.bin'
   456 2AA7			palette_bin
   457 2AA7 00 56 99 47 09 05 +     ins 'palette_monster.bin'
   458 				;---------------------------------------------
   459
   460 				.endp; vbxe 
    38 2DA7			    icl 'os.asm'
Source: C:\CC65\Projects\VBXE\VBXE wrapper\os.asm
     1 				;##################################################
     2 				; os.asm
     3 				;##################################################
     4
     5
     6 				;##################################################
     7 				; replace the OS NMI handler with our own
     8 				;##################################################
     9 2DA7			.proc nmi_handler
    10 2DA7 2C 0F D4		    	bit nmires
    11 2DAA 10 03		    	bpl not_dli
    12 2DAC 6C 00 02		    	jmp (VDSLST)
    13 2DAF			not_dli:
    14 2DAF D8					cld
    15 2DB0 48					pha
    16 2DB1 8A					txa
    17 2DB2 48					pha
    18 2DB3 98					tya
    19 2DB4 48					pha
    20 2DB5 8D 0F D4				sta nmires
    21 2DB8 6C 22 02				jmp (VVBLKI)
    22
    23 2DBB 60					rts
    24 				.endp
    25
    26
    27 				;##################################################
    28 				; default VBI routine when disabling OS
    29 				;##################################################
    30 2DBC			.proc default_vbi_routine	
    31
    32 2DBC A9 01			lda #$01
    33 2DBE 8D FF 2D			sta default_vblank
    34
    35 2DC1 68				pla
    36 2DC2 A8			    tay
    37 2DC3 68			    pla
    38 2DC4 AA			    tax
    39 2DC5 68			    pla
    40 2DC6 40			    rti
    41
    42 				.endp
    43
    44 				;##################################################
    45 				; wait until VBLANK occured
    46 				;##################################################
    47 2DC7			.proc wait_for_default_vblank
    48 2DC7			@
    49 2DC7 AD FF 2D			lda default_vblank
    50 2DCA C9 00			cmp #$00
    51 2DCC F0 F9			beq @-
    52
    53 2DCE A9 00			lda #$00
    54 2DD0 8D FF 2D			sta default_vblank
    55
    56 2DD3 60				rts
    57 				.endp 
    58
    59
    60 				;##################################################
    61 				; use RAM under ROM by setting FE into PORTB
    62 				;##################################################
    63 2DD4			.proc disable_os
    64 2DD4 78			    sei
    65 2DD5 D8			    cld
    66 2DD6 A9 00		    lda #$00  
    67 2DD8 8D 0E D2		    sta IRQEN
    68 2DDB A9 00		    lda #$00
    69 2DDD 8D 0E D4		    sta NMIEN
    70 2DE0 A9 FE			lda #$FE
    71 2DE2 8D 01 D3			sta PORTB
    72 					
    73 2DE5 A9 A7 8D FA FF A9 + 	mwa #nmi_handler NMI
    74 2DEF A9 BC 8D 22 02 A9 + 	mwa #default_vbi_routine VVBLKI
    75
    76 2DF9 A9 40			lda #$40
    77 2DFB 8D 0E D4			sta NMIEN
    78 					
    79 2DFE 60				rts
    80 				.endp
    81 				;-----------------------
    82
    83
    84 				;-----------------------
    85 				; variables 
    86 				;-----------------------
    87 2DFF 00			default_vblank  .byte   0
